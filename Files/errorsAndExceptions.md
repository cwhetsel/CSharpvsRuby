# Errors and Exception handling

## C# Errors/Excpetions
>The C# language's exception handling features help you deal with any unexpected or exceptional situations that occur when a program is running. Exception handling uses the try, catch, and finally keywords to try actions that may not succeed, to handle failures when you decide that it is reasonable to do so, and to clean up resources afterward. Exceptions can be generated by the common language runtime (CLR), by the .NET Framework or any third-party libraries, or by application code. Exceptions are created by using the throw keyword.

>In many cases, an exception may be thrown not by a method that your code has called directly, but by another method further down in the call stack. When this happens, the CLR will unwind the stack, looking for a method with a catch block for the specific exception type, and it will execute the first such catch block that if finds. If it finds no appropriate catch block anywhere in the call stack, it will terminate the process and display a message to the user.

#### Exception Overview
- Exceptions are types that all ultimately derive from System.Exception.
- Use a try block around the statements that might throw exceptions.
- Once an exception occurs in the try block, the flow of control jumps to the first associated exception handler that is present anywhere in the call stack. In C#, the catch keyword is used to define an exception handler.
- If no exception handler for a given exception is present, the program stops executing with an error message.
- Do not catch an exception unless you can handle it and leave the application in a known state. If you catch System.Exception, rethrow it using the throw keyword at the end of the catch block.
- If a catch block defines an exception variable, you can use it to obtain more information about the type of exception that occurred.
- Exceptions can be explicitly generated by a program by using the throw keyword.
- Exception objects contain detailed information about the error, such as the state of the call stack and a text description of the error.
- Code in a finally block is executed even if an exception is thrown. Use a finally block to release resources, for example to close any streams or files that were opened in the try block.

example
```csharp
class ExceptionTest
{
    static double SafeDivision(double x, double y)
    {
        if (y == 0)
            throw new System.DivideByZeroException();
        return x / y;
    }
    static void Main()
    {
        // Input for test purposes. Change the values to see
        // exception handling behavior.
        double a = 98, b = 0;
        double result = 0;

        try
        {
            result = SafeDivision(a, b);
            Console.WriteLine("{0} divided by {1} = {2}", a, b, result);
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine("Attempted divide by zero.");
        }
    }
}
```
### REFERENCES
(https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/exceptions/index)

## Ruby Errors/Exceptions
In Ruby, errors are handled by raising exceptions in the code.
>Every ruby library raises an exception if any error occurs, and you can raise exceptions explicitly in your code too. To raise an exception, use raise. It takes one argument, which should be a string that describes the exception. The argument is optional but should not be omitted. It can be accessed later via the special global variable $!.

To execute a block of code that may raise an exception, you use the begin/rescue/ensure structure. Begin contains the code to be attempted, rescue is called if an exception is raised and ensure is executed after the begin block whether an exception is raised or not. *retry* keyword may be used in the rescue block to try to execute the begin block again. However, this may cause an infinite loop so you must be careful when using it.
```ruby
fname = "some_file"
begin
  file = open(fname)
  # ... process the input ...
rescue
  #retry the begin bock with fname as the standard input now if an exception is raised
  fname = "STDIN"
  retry
end

#example with ensure
file = open("/tmp/some_file", "w")
begin
  # ... write to the file ...
  raise "Failed to write to file"
rescue
  # ... handle the exceptions ...
ensure
  file.close   # ... and this always happens.
end
```
### REFERENCES
(http://www.rubyist.net/~slagell/ruby/ensure.html)
